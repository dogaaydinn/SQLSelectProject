name: Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version/Tag to deploy'
        required: false
        default: 'latest'

env:
  ENVIRONMENT: development
  NAMESPACE: employee-mgmt-dev

jobs:
  deploy:
    name: Deploy to Development
    runs-on: ubuntu-latest
    environment:
      name: development
      url: https://dev.employee-mgmt.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_DEV }}" | base64 -d > kubeconfig
          export KUBECONFIG=./kubeconfig

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy ConfigMaps
        run: |
          kubectl apply -f k8s/base/configmaps/ -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/overlays/development/configmaps/ -n ${{ env.NAMESPACE }}

      - name: Deploy Secrets
        run: |
          kubectl create secret generic app-secrets \
            --from-literal=database-url="${{ secrets.DEV_DATABASE_URL }}" \
            --from-literal=redis-url="${{ secrets.DEV_REDIS_URL }}" \
            --from-literal=jwt-secret="${{ secrets.DEV_JWT_SECRET }}" \
            --dry-run=client -o yaml | kubectl apply -f - -n ${{ env.NAMESPACE }}

      - name: Deploy Database
        run: |
          kubectl apply -f k8s/base/postgres/ -n ${{ env.NAMESPACE }}

      - name: Deploy Redis
        run: |
          kubectl apply -f k8s/base/redis/ -n ${{ env.NAMESPACE }}

      - name: Deploy API
        run: |
          kubectl apply -f k8s/base/api-python/ -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/overlays/development/api-python/ -n ${{ env.NAMESPACE }}

      - name: Deploy Monitoring
        run: |
          kubectl apply -f k8s/base/monitoring/ -n ${{ env.NAMESPACE }}

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/api-python -n ${{ env.NAMESPACE }} --timeout=5m

      - name: Run smoke tests
        run: |
          # Get the service URL
          API_URL=$(kubectl get svc api-python -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          # Wait for service to be ready
          echo "Waiting for API to be ready..."
          for i in {1..30}; do
            if curl -f http://${API_URL}/health; then
              echo "API is healthy!"
              break
            fi
            echo "Waiting... attempt $i/30"
            sleep 10
          done

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Deployed Resources" >> $GITHUB_STEP_SUMMARY
          kubectl get all -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY

      - name: Notify deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Deployment to Development: ${{ job.status }}
            Environment: ${{ env.ENVIRONMENT }}
            Commit: ${{ github.sha }}
            Actor: ${{ github.actor }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        continue-on-error: true
